// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use super::{Arg2Parser, ArgParseRes, ContextFreeArgParser};

/// This parser combines several context free argument parsers, that all return
/// the same result type, trying them one by one, in order.  It is designed to
/// be used with arguments that have several different forms.  The first parser,
/// in order that succeeds is considered to be the result of the
/// `AlternativesArgParser` parser.  In case no parser succeeds the combined
/// parser error is the error generated by the parser that managed to parse the
/// most of the input.
///
/// Hints, if any, are combined from all the parsers.
pub struct ContextFreeAlternativesArgParser<Res> {
    parsers: Vec<Box<dyn ContextFreeArgParser<Res>>>,
}

pub fn alternatives_cf<Res, Parsers>(
    parsers: Parsers,
) -> ContextFreeAlternativesArgParser<Res>
where
    Parsers: IntoIterator<Item = Box<dyn ContextFreeArgParser<Res>>>,
{
    let parsers = parsers.into_iter().collect::<Vec<_>>();

    if parsers.is_empty() {
        panic!("`parsers` should not be empty");
    }

    ContextFreeAlternativesArgParser { parsers }
}

impl<Res> ContextFreeArgParser<Res> for ContextFreeAlternativesArgParser<Res> {
    fn parse(&self, input: &str) -> ArgParseRes<Res> {
        let mut parsers = self.parsers.iter();

        let mut combined_res = {
            // `self.parsers` must be non-empty.
            let parser = parsers.next().unwrap();

            parser.parse(input)
        };

        for parser in parsers {
            let res = parser.parse(input);

            combined_res = combined_res.merge(res);
        }

        combined_res
    }

    fn suggestion(&self, prefix: &str) -> Vec<String> {
        self.parsers
            .iter()
            .flat_map(|parser| parser.suggestion(prefix))
            .collect()
    }

    fn hint(&self) -> Vec<String> {
        self.parsers
            .iter()
            .flat_map(|parser| parser.hint())
            .collect()
    }
}

/// Generates "context-sensitive" alternatives argument parser - similar to
/// [`ContextFreeAlternativesArgParser`] but for [`Arg2Parser`] and friends.
/// You can use [`ContextFreeArgParser::adapt()`] if you need to use a context
/// free argument parser as part of an alternative that is used for a
/// non-context free argument.
macro_rules! define_alternatives_arg_parser {
    (
        $type_name:ident: $parser_trait:ident,
        $constructor_name:ident,
        { $( $arg_name:ident: $arg_type:ident ),* $(,)* },
        $res:ident
    ) => {
        pub struct $type_name<$( $arg_type, )* $res> {
            parsers: Vec<Box<dyn $parser_trait<$( $arg_type, )* $res>>>,
        }

        // TODO: Currently only used in tests.
        #[cfg(test)]
        pub fn $constructor_name<$( $arg_type, )* $res, Parsers>(
            parsers: Parsers,
        ) -> $type_name<$( $arg_type, )* $res>
        where
            Parsers:
                IntoIterator<Item =
                    Box<dyn $parser_trait<$( $arg_type, )* $res>>>,
        {
            let parsers = parsers.into_iter().collect::<Vec<_>>();

            if parsers.is_empty() {
                panic!("`parsers` should not be empty");
            }

            $type_name { parsers }
        }

        impl<$( $arg_type, )* $res> $parser_trait<$( $arg_type, )* $res>
            for $type_name<$( $arg_type, )* $res>
        {
            fn parse(&self, $( $arg_name: &$arg_type, )* input: &str)
                -> ArgParseRes<$res>
            {
                let mut parsers = self.parsers.iter();

                let mut combined_res = {
                    // `self.parsers` must be non-empty.
                    let parser = parsers.next().unwrap();

                    parser.parse($( $arg_name, )* input)
                };

                for parser in parsers {
                    let res = parser.parse($( $arg_name, )* input);

                    combined_res = combined_res.merge(res);
                }

                combined_res
            }

            fn suggestion(&self, $( $arg_name: &$arg_type, )* prefix: &str)
                -> Vec<String>
            {
                self.parsers.iter()
                    .flat_map(|parser|
                        parser.suggestion($( $arg_name, )* prefix))
                    .collect()
            }

            fn hint(&self, $( $arg_name: &$arg_type, )*) -> Vec<String> {
                self.parsers.iter()
                    .flat_map(|parser| parser.hint($( $arg_name, )*))
                    .collect()
            }
        }
    }
}

define_alternatives_arg_parser!(
    AlternativesArg2Parser: Arg2Parser,
    alternatives_arg2,
    { res1: Res1, },
    Res2
);

// define_alternatives_arg_parser!(
//     AlternativesArg3Parser: Arg3Parser,
//     alternatives_arg3,
//     { res1: Res1, res2: Res2, },
//     Res3
// );

#[cfg(test)]
mod tests {
    use super::{alternatives_arg2, alternatives_cf};

    use crate::input::arg_parser::keyword_set;
    use crate::input::arg_parser::prim_int_for_range;
    use crate::input::arg_parser::test_utils::{
        build_arg2_parse_checkers, build_cf_parse_checkers,
    };
    use crate::input::arg_parser::{Arg2Parser, ContextFreeArgParser};

    #[test]
    fn simple_cf_alternatives() {
        #[derive(PartialEq, Clone, Debug)]
        enum TestArg {
            Number(u8),
            One,
            Other,
        }

        use TestArg::*;

        let parser = {
            let opt1 = prim_int_for_range(0, 10).map(Number).boxed();

            let ks = &["one", "other"];
            let opt2 = keyword_set(ks)
                .map(|k| match k.as_str() {
                    "one" => One,
                    "other" => Other,
                    _ => panic!("Unexpected keyword"),
                })
                .boxed();

            alternatives_cf(vec![opt1, opt2])
        };

        let expected_above_hint = &["max: 10"];
        let expected_combined_hint = &["<0-10>", "one", "other"];
        let expected_number_hint = &["<0-10>"];
        let expected_keyword_hint = &["one", "other"];

        let (check_hint, check_suggestions, check_parse, check_failure) =
            build_cf_parse_checkers("parser", parser);

        check_hint(expected_combined_hint);

        check_parse("0", Number(0));
        check_parse("1", Number(1));
        check_parse("10", Number(10));
        check_parse("one", One);
        check_parse("other", Other);

        check_failure("-1", 2, expected_number_hint);
        check_failure("-11", 3, expected_number_hint);
        check_failure("", 0, expected_combined_hint);
        check_failure("a", 0, expected_combined_hint);
        check_failure("z", 0, expected_combined_hint);
        check_failure("*", 0, expected_combined_hint);
        check_failure("17", 2, expected_above_hint);
        check_failure("100000", 6, expected_number_hint);
        check_failure("o", 1, expected_keyword_hint);
        check_failure("on", 2, expected_keyword_hint);
        check_failure("one-", 3, expected_keyword_hint);
        check_failure("ot", 2, expected_keyword_hint);
        check_failure("other-", 5, expected_keyword_hint);

        check_suggestions("", &["one", "other"]);
        check_suggestions("o", &["one", "other"]);
        check_suggestions("on", &["one"]);
        check_suggestions("ot", &["other"]);
        check_suggestions("ott", &[]);
    }

    #[test]
    fn simple_arg2_alternatives() {
        #[derive(PartialEq, Clone, Debug)]
        enum TestArg {
            Number(u64),
            One(u8),
            Other(u8),
        }

        use TestArg::*;

        let parser = {
            let int_parser = prim_int_for_range(0u8, 10);
            let opt1 =
                Arg2Parser::map(int_parser.adapt(), |arg1: &u8, arg2| {
                    Number((*arg1 as u64) * 100 + (arg2 as u64))
                })
                .boxed();

            let ks = &["one", "other"];
            let keyword_parser = keyword_set(ks);
            let opt2 =
                Arg2Parser::map(
                    keyword_parser.adapt(),
                    |arg1, arg2| match arg2.as_str() {
                        "one" => One(*arg1),
                        "other" => Other(*arg1),
                        _ => panic!("Unexpected keyword"),
                    },
                )
                .boxed();

            alternatives_arg2(vec![opt1, opt2])
        };

        let expected_above_hint = &["max: 10"];
        let expected_combined_hint = &["<0-10>", "one", "other"];
        let expected_number_hint = &["<0-10>"];
        let expected_keyword_hint = &["one", "other"];

        let (check_hint, check_suggestions, check_parse, check_failure) =
            build_arg2_parse_checkers("parser", parser);

        check_hint(&0, expected_combined_hint);

        check_parse(&7, "0", Number(700));
        check_parse(&3, "1", Number(301));
        check_parse(&11, "10", Number(1110));
        check_parse(&0, "one", One(0));
        check_parse(&23, "other", Other(23));

        check_failure(&7, "-1", 2, expected_number_hint);
        check_failure(&45, "-11", 3, expected_number_hint);
        check_failure(&83, "", 0, expected_combined_hint);
        check_failure(&42, "a", 0, expected_combined_hint);
        check_failure(&58, "z", 0, expected_combined_hint);
        check_failure(&89, "*", 0, expected_combined_hint);
        check_failure(&92, "17", 2, expected_above_hint);
        check_failure(&19, "100000", 6, expected_number_hint);
        check_failure(&63, "o", 1, expected_keyword_hint);
        check_failure(&1, "on", 2, expected_keyword_hint);
        check_failure(&43, "one-", 3, expected_keyword_hint);
        check_failure(&56, "ot", 2, expected_keyword_hint);
        check_failure(&41, "other-", 5, expected_keyword_hint);

        check_suggestions(&41, "", &["one", "other"]);
        check_suggestions(&65, "o", &["one", "other"]);
        check_suggestions(&18, "on", &["one"]);
        check_suggestions(&36, "ot", &["other"]);
        check_suggestions(&25, "ott", &[]);
    }
}
