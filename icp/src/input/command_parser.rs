// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! A "quick and dirty" parser for commands that have a structure where a
//! command is identified by the first word of the input and the rest is parsed
//! as a sequence of "arguments" left to right.
//!
//! Current implementation is a "one level" recursive decent solution - every
//! command parser will try to parse the first word and will use a sequence of
//! argment parsers, to parse the command arguments that follow.
//!
//! Command parsers are instances of the [`CommandParser`] trait.  Predefined
//! command parsers are provided as [`Command0ArgsParser`],
//! [`Command1ArgParser`], [`Command2ArgsParser`], - they are generated by the
//! [`define_command_parser`] macro.  If necessary the macro can be called to
//! generate command parsers for longer commands.
//!
//! For argument parsers see the [`input::arg_parser`] module.
//!
//! TODO: Ideally, input should be parsed by a grammar and command should
//! provide grammars that are combined into an "input language" grammar.  This a
//! more complex approach, but it should provide a more uniform and generic
//! solution to both error reporting and completion.  As well as allow for
//! complex language when commands could be using other commands as arguments,
//! or if we want some kind of "command modification" language.

pub mod alternatives;
#[cfg(test)]
pub mod test_utils;

use lazy_static::lazy_static;
use regex::Regex;

use std::cmp::Ordering;
use std::marker::PhantomData;

use super::arg_parser::{Arg2Parser, ArgParseRes, ContextFreeArgParser};

pub use alternatives::alternatives_cmd;

/// Different kinds of ways a parse may go wrong.
#[derive(PartialEq, Clone, Debug)]
pub enum CommandParseFailure {
    /// Failed to parse one of the arguments.
    ArgumentParseFailed {
        /// First character of the argument that failed to parse.
        from: usize,

        /// Position just after the last character forming the argument that
        /// failed to parse.
        to: usize,

        /// Explanation as to why this input did not match the expectation.  In
        /// case a command can parse this argument in multiple different ways
        /// and all have failed, there could be several explanations as to what
        /// was actually expected.
        reason: Vec<String>,
    },

    /// Input form a prefix of a valid command, with all the arguments parsed
    /// correctly, but to form a complete command it needs one or more
    /// additional arguments.
    ExpectedArg {
        /// A 0-based index of the missing argument.  Mostly convenient for
        /// error messages, such as "Missing argument {index}".
        index: usize,

        /// Holds suggestions as to what the missing argument could look like.
        /// If an argument might have several different forms, a `Vec` allows
        /// for all of those to be described.
        hint: Vec<String>,
    },

    /// A full command has been parsed correctly, but the input contains
    /// additional characters.
    UnexpectedArgument {
        /// First character of an unexpected argument, following the
        /// successfully parsed part.
        from: usize,
    },
}

impl CommandParseFailure {
    /// Returns a relative order of the `CommandParseFailure` cases, when
    /// sorting on "potential usefulness".  When two failures show parsing
    /// failed at the same character, and we need to select only one failure to
    /// show to the user, we select one with the highest
    /// `merge_preference_order()`.  See [`CommandParseRes::merge()`].
    fn merge_preference_order(&self) -> usize {
        match self {
            CommandParseFailure::ArgumentParseFailed { .. } => 2,
            CommandParseFailure::ExpectedArg { .. } => 1,
            CommandParseFailure::UnexpectedArgument { .. } => 0,
        }
    }
}

/// Result of parsing an input string as a command.
#[derive(PartialEq, Clone, Debug)]
pub enum CommandParseRes<Res> {
    /// Input string formed a complete command.  `Res` holds the command
    /// description.
    Parsed(Res),

    /// Input string did not form a complete command.
    Failed {
        /// The last character in the input that makes sense according to this
        /// parsing.  `CommandParseRes` that are failures are compared using
        /// this field.  This should not include any argument separators.
        parsed_up_to: usize,

        reason: CommandParseFailure,
    },
}

impl<Res> CommandParseRes<Res> {
    /// Combines two `CommandParseRes` results, giving `self` preference in case
    /// they are considered equal.
    ///
    /// `Parsed` is preferred over any kind of failure.  One failure is
    /// preferred over another if the first happened at a later position.
    ///
    /// If both are [`CommandParseFailure::ExpectedArg`] and they failed at the
    /// same character, then we would produce a combined version that will
    /// contain `hint` values from both errors.
    pub fn merge(self, other: CommandParseRes<Res>) -> CommandParseRes<Res> {
        match (self, other) {
            (me @ CommandParseRes::Parsed(_), _other) => me,
            (_me, other @ CommandParseRes::Parsed(_)) => other,
            (
                CommandParseRes::Failed {
                    parsed_up_to: me_parsed_up_to,
                    reason: me_reason,
                },
                CommandParseRes::Failed {
                    parsed_up_to: other_parsed_up_to,
                    reason: other_reason,
                },
            ) => match (me_parsed_up_to, me_reason.merge_preference_order())
                .cmp(&(
                    other_parsed_up_to,
                    other_reason.merge_preference_order(),
                )) {
                Ordering::Less => CommandParseRes::Failed {
                    parsed_up_to: other_parsed_up_to,
                    reason: other_reason,
                },
                Ordering::Greater => CommandParseRes::Failed {
                    parsed_up_to: me_parsed_up_to,
                    reason: me_reason,
                },
                Ordering::Equal => match (me_reason, other_reason) {
                    (
                        CommandParseFailure::ExpectedArg {
                            index: me_index,
                            hint: mut me_hint,
                        },
                        CommandParseFailure::ExpectedArg {
                            index: other_index,
                            hint: mut other_hint,
                        },
                    ) => {
                        debug_assert!(
                            me_index == other_index,
                            "`CommandParseRes::merge()` was given two \
                             `CommandParseRes::ExpectedArg` values with \
                             different `index` values.  This should not happen \
                             and is not supported."
                        );
                        me_hint.append(&mut other_hint);
                        CommandParseRes::Failed {
                            parsed_up_to: me_parsed_up_to,
                            reason: CommandParseFailure::ExpectedArg {
                                index: me_index,
                                hint: me_hint,
                            },
                        }
                    }
                    (me_reason, _other_reason) => CommandParseRes::Failed {
                        parsed_up_to: me_parsed_up_to,
                        reason: me_reason,
                    },
                },
            },
        }
    }
}

/// As a side effect of parsing a command we may get a set of suggestions
/// starting at the specified character.  Suggestions are only produced when all
/// the arguments to the left of the argument holding the specified character
/// have been parsed correctly, while the argument with the specified character
/// forms a valid prefix up to the character itself.
#[derive(PartialEq, Clone, Debug)]
pub struct CommandSuggestions(Vec<String>);

impl From<Vec<String>> for CommandSuggestions {
    fn from(suggestions: Vec<String>) -> Self {
        CommandSuggestions(suggestions)
    }
}

impl From<CommandSuggestions> for Vec<String> {
    fn from(suggestions: CommandSuggestions) -> Self {
        suggestions.0
    }
}

/// Command parser that takes an input string and a cursor position and parses
/// the input as some command, at the same time, trying to produce a list of
/// suggestions for the characters specified by the `pos` argument.  These
/// suggestions are expected to extend the input towards something that this
/// parser can parse.
///
/// In case the caller wants to just parse the input, and the cursor is not in
/// the argument part of the command, `pos` can be set to `None`.
///
/// See [`CommandParseRes`] for details on the parsing result.  Suggestions are
/// only generated if all the arguments up before the one holding the `pos`
/// character have been successfully parsed.
pub trait CommandParser<Res> {
    fn parse(
        &self,
        input: &str,
        pos: Option<usize>,
    ) -> (CommandParseRes<Res>, Option<CommandSuggestions>);

    /// It is very common to box command parsers, as their type parameters are
    /// not always expressible, and thus, one can not write an actual type of a
    /// command parser.  It also happens when we want to put parsers of
    /// different types into a vector.  This method helps to remove some of the
    /// syntactic noise.
    fn boxed(self) -> Box<dyn CommandParser<Res>>
    where
        Self: Sized + 'static,
    {
        Box::new(self) as Box<dyn CommandParser<Res>>
    }
}

/// A command parser that expects no arguments.
///
/// Command parsers for commands with arguments use a function to combined those
/// argument values into the final parser value.  This parser has no arguments,
/// but it still takes a function that generates the final result of the parse.
/// `Res` is the type of the parse and `Combine` is the function that takes no
/// arguments and returns a `Res` value.  A function makes it possible to return
/// values that can not be copied.
pub struct Command0ArgsParser<Combine, Res>
where
    Combine: Fn() -> Res,
{
    combine: Combine,
    _res: PhantomData<Res>,
}

pub fn command_no_args<Combine, Res>(
    combine: Combine,
) -> Command0ArgsParser<Combine, Res>
where
    Combine: Fn() -> Res,
{
    Command0ArgsParser {
        combine,
        _res: PhantomData,
    }
}

impl<Combine, Res> CommandParser<Res> for Command0ArgsParser<Combine, Res>
where
    Combine: Fn() -> Res,
{
    fn parse(
        &self,
        input: &str,
        _pos: Option<usize>,
    ) -> (CommandParseRes<Res>, Option<CommandSuggestions>) {
        lazy_static! {
            static ref WORD: Regex = Regex::new(r"\S+").unwrap();
        }

        let res = match WORD.find(input) {
            Some(m) => CommandParseRes::Failed {
                parsed_up_to: 0,
                reason: CommandParseFailure::UnexpectedArgument {
                    from: m.start(),
                },
            },
            None => CommandParseRes::Parsed((self.combine)()),
        };

        (res, None)
    }
}

/// Generates "command parser" type for context sensitive argument parsers.  See
/// [`CommandParser`] for details of what a command parser does
///
/// This command parser contains context-sensitive argument parsers, which it
/// will apply one by one.  It will also generate a set of suggestions for the
/// cursor position, matching the [`CommandSuggestions`] description.
///
/// The need for macro arises from the following: depending on the number of
/// arguments in the command the number of parsers to be applied is different,
/// and every argument parser receives references to the values that were
/// successfully parsed by all the preceding parsers.
///
/// A parser for a command with one argument is rather simple: it will try an
/// `Arg1Parser` and will return it's result.  A parser for a command with two
/// arguments is more complex, it will first apply an `Arg1Parser`, next it will
/// call an `Arg2Parser` providing the value generated by the first parser as an
/// argument.
///
/// In any case the return value is the `CommandParseRes` enum, with `Res` been
/// a tuple holding values generated by all the parser.
///
/// Here is a simplification of how the command parsers look like:
///
/// ```ignore
/// pub struct Command1ArgParser<Parser1, Res1, Combine, Res>
/// where
///     Parser1: Arg1Parser<Res1>,
///     Combine: Fn(Res1) -> Res,
/// {
///     ...
/// }
///
/// pub fn command_1arg<Parser1, Res1, Combine, Res>(
///     arg1_parser: Parser1,
///     combine: Combine
/// ) -> Command1ArgParser<Parser1, Res1, Combine, Res>
/// where
///     Parser1: Arg1Parser<Res1>,
///     Combine: Fn(Res1) -> Res,
/// {
///     ...
/// }
///
/// impl<Parser1, Res1, Combine, Res>
///     CommandParser<Res> for Command1ArgParser<Parser1, Res1, Combine, Res>
/// where
///     Parser1: Arg1Parser<Res1>,
///     Combine: Fn(Res1) -> Res,
/// {
///     fn parser(input: &str, pos: Option<usize>) -> CommandParseRes<Res>
///     {
///         // Split `input` on word boundaries, producing `arg1`.
///
///         let mut suggestions = None;
///
///         let res1 = self.arg1_parser.parse(arg1);
///         if pos.is_some() && pos.unwrap() in arg1-indices {
///             suggestions =
///                 Some(self.arg1_parser.suggestions(arg1[0..pos.unwrap()]));
///         }
///
///         (CommandParseRes::Parsed((self.combine)(res1)), suggestions)
///     }
/// }
///
/// pub struct Command2ArgsParser<Parser1, Res1, Parser2, Res2, Combine, Res>
/// where
///     Parser1: Arg1Parser<Res1>,
///     Parser2: Arg2Parser<Res2>,
///     Combine: Fn(Res1, Res2) -> Res,
/// {
///     ...
/// }
///
/// pub fn command_2args<Parser1, Res1, Parser2, Res2, Combine, Res>(
///         arg1_parser: Parser1,
///         arg2_parser: Parser2,
///         combine: Combine
/// ) -> Command2ArgsParser<Parser1, Res1, Parser2, Res2, Combine, Res>
/// where
///     Parser1: Arg1Parser<Res1>,
///     Parser2: Arg2Parser<Res2>,
///     Combine: Fn(Res1, Res2) -> Res,
/// {
///     ...
/// }
///
/// impl<Parser1, Res1, Parser2, Res2, Combine, Res>
///     CommandParser<Res> for
///     Command2ArgsParser<Parser1, Res1, Parser2, Res2, Combine, Res>
/// where
///     Parser1: Arg1Parser<Res1>,
///     Parser2: Arg2Parser<Res2>,
///     Combine: Fn(Res1, Res2) -> Res,
/// {
///     fn parser(input: &str, pos: Option<usize>) -> CommandParseRes<Res>
///     {
///         // Split `input` on word boundaries, producing `arg1` and `arg2`.
///
///         let mut suggestions = None;
///
///         let res1 = self.arg1_parser.parse(arg1);
///         if pos.is_some() && pos.unwrap() in arg1-indices {
///             suggestions =
///                 Some(self.arg1_parser.suggestions(arg1[0..pos.unwrap()]));
///         }
///
///         let res2 = self.arg2_parser.parse(&res1, arg2);
///         if pos && pos.unwrap() in arg1-indices {
///             suggestions =
///                 Some(self.arg2_parser.suggestions(
///                     &res1, arg1[0..<adjusted pos>]));
///         }
///
///         (CommandParseRes::Parsed((self.combine)(res1, res2)), suggestions)
///     }
/// }
/// ```
///
/// Generated parsers check for error cases and the `ParserN::suggestions()`
/// calls are a bit more complex.
macro_rules! define_command_parser {
    // Entry point.
    //
    // Here we start our "pre-processing loop" were we generated all sequences
    // that will then be used to construct the final definition.  We need a
    // bunch of sequences, such as "all the parser types", "types of all the
    // parsers before this one", "names of variables holding results for all the
    // parsers before this one", and so on, as well as "current argument index".
    ($type_name:ident, $final_res_tyvar:ident,
     $constructor_name:ident,
     $(
        $parser_field:ident: <$parser_tyvar:ident: $arg_parser_trait:ident>
            => $res_var:ident: $res_tyvar:ident ( $res_phantom_field:ident )
      ),+ $(,)*
    ) => {
        define_command_parser!(
            @unprocessed: { $(
                $parser_field: $parser_tyvar: $arg_parser_trait,
                $res_var: $res_tyvar, $res_phantom_field,
            )* }
            @type_name: $type_name
            @constructor_name: $constructor_name
            @final_res: $final_res_tyvar
            @parsers_info: { }
            @parser_res_info: { }
            @arg_index: 0usize ;
        );
    };

    // One parsing loop iteration.
    //
    // Takes details describing the next argument parser and inserts them into
    // all the sequences we are building.
    (
        @unprocessed: {
            $head_parser_field:ident:
                $head_parser_tyvar:ident:
                $head_arg_parser_trait:ident,
            $head_res_var:ident: $head_res_tyvar:ident,
            $head_res_phantom_field:ident,
            $( $tail_parser_field:ident: $tail_parser_tyvar:ident:
                $tail_arg_parser_trait:ident,
               $tail_res_var:ident: $tail_res_tyvar:ident,
               $tail_res_phanton_field:ident,
            )*
        }
        @type_name: $type_name:ident
        @constructor_name: $constructor_name:ident
        @final_res: $final_res_tyvar:ident
        @parsers_info: { $(
            $parser_field:ident,
            $parser_tyvar:ident,
            $arg_parser_trait:ident,
            { $( $arg_parser_trait_arg:ident, )* },
            { $( $prev_parser_res:ident, )* },
            $arg_index:expr,
            $res_var:ident,
            $res_tyvar:ident
        ),* }
        @parser_res_info: { $(
            $parser_res_type:ident,
            $parser_res_var:ident,
            $parser_res_phantom_field:ident,
        )* }
        @arg_index: $arg_index_acc:expr ;
    ) => {
        define_command_parser!(
            @unprocessed: {
                $( $tail_parser_field:
                       $tail_parser_tyvar: $tail_arg_parser_trait,
                   $tail_res_var: $tail_res_tyvar,
                   $tail_res_phanton_field,
                )*
            }
            @type_name: $type_name
            @constructor_name: $constructor_name
            @final_res: $final_res_tyvar
            @parsers_info: {
                $(
                    $parser_field,
                    $parser_tyvar,
                    $arg_parser_trait,
                    { $( $arg_parser_trait_arg, )* },
                    { $( $prev_parser_res, )* },
                    $arg_index,
                    $res_var,
                    $res_tyvar,
                )*
                $head_parser_field,
                $head_parser_tyvar,
                $head_arg_parser_trait,
                { $( $parser_res_type, )* $head_res_tyvar, },
                { $( $parser_res_var, )* },
                $arg_index_acc,
                $head_res_var,
                $head_res_tyvar
            }
            @parser_res_info: {
                $(
                    $parser_res_type,
                    $parser_res_var,
                    $parser_res_phantom_field,
                )*
                $head_res_tyvar,
                $head_res_var,
                $head_res_phantom_field,
            }
            @arg_index: $arg_index_acc + 1usize ;
        );
    };

    // No more arguments have left.
    //
    // We should have accumulated proper sequences by now, so we can just output
    // the struct and instance definitions, using the accumulated type/variable
    // sequences.
    (
        @unprocessed: { }
        @type_name: $type_name:ident
        @constructor_name: $constructor_name:ident
        @final_res: $final_res_tyvar:ident
        @parsers_info: { $(
            $parser_field:ident,
            $parser_tyvar:ident,
            $arg_parser_trait:ident,
            { $( $arg_parser_trait_arg:ident, )* },
            { $( $prev_parser_res:ident, )* },
            $arg_index:expr,
            $res_var:ident,
            $res_tyvar:ident
        ),* }
        @parser_res_info: { $(
            $parser_res_type:ident,
            $parser_res_var:ident,
            $parser_res_phantom_field:ident,
        )* }
        @arg_index: $_arg_index_acc:expr ;
    ) => {
        pub struct $type_name<
            $( $parser_tyvar, $res_tyvar, )* Combine,
            $final_res_tyvar
        >
        where
            $(
                $parser_tyvar:
                    $arg_parser_trait< $( $arg_parser_trait_arg, )* >,
            )*
            Combine: Fn( $( $res_tyvar, )* ) -> $final_res_tyvar,
        {
            $(
                $parser_field: $parser_tyvar,
            )*
            combine: Combine,
            $(
                $parser_res_phantom_field: PhantomData<$parser_res_type>,
            )*
        }

        pub fn $constructor_name<
            $( $parser_tyvar, $res_tyvar, )*
            Combine,
            $final_res_tyvar,
        >(
            $( $parser_field: $parser_tyvar, )*
            combine: Combine,
        ) -> $type_name<
            $( $parser_tyvar, $res_tyvar, )*
            Combine,
            $final_res_tyvar,
        >
        where
            $(
                $parser_tyvar:
                    $arg_parser_trait< $( $arg_parser_trait_arg, )* >,
            )*
            Combine: Fn( $( $res_tyvar, )* ) -> $final_res_tyvar,
        {
            $type_name {
                $( $parser_field, )*
                combine,
                $( $parser_res_phantom_field: PhantomData, )*
            }
        }

        impl<$( $parser_tyvar, $res_tyvar, )* Combine, $final_res_tyvar>
            CommandParser<$final_res_tyvar> for
            $type_name<
                $( $parser_tyvar, $res_tyvar, )*
                Combine,
                $final_res_tyvar,
            >
        where
            $(
                $parser_tyvar:
                    $arg_parser_trait< $( $arg_parser_trait_arg, )* >,
            )*
            Combine: Fn( $( $res_tyvar, )* ) -> $final_res_tyvar,
        {
            // `prev_arg_end` is assigned one extra time for the very last
            // argument.  It is tricky to omit generation of the assignment just
            // for the last argument, so instead I just ignore the warning.
            // Unfortunately, ignoring warnings at the expression level is
            // currently a nightly only feature, so ignore for the whole method.
            #[allow(unused_assignments)]
            fn parse(&self, input: &str, pos: Option<usize>)
                -> (CommandParseRes<Res>, Option<CommandSuggestions>)
            {
                lazy_static! {
                    static ref WORD: Regex = Regex::new(r"\S+").unwrap();
                }

                use CommandParseFailure::{
                    ArgumentParseFailed, ExpectedArg, UnexpectedArgument,
                };

                let mut args_iter = WORD.find_iter(input);
                let mut suggestions = None;

                // Remember the previous argument end character in order to know
                // if we need to provide suggestions for an absent argument at
                // the end.  Also used in parse errors as the last successfully
                // parsed character.
                let mut prev_arg_end = 0;

                $(
                    let $res_var = match args_iter.next() {
                        Some(m) => {
                            let start = m.start();
                            let end = m.end();
                            let arg = m.as_str();

                            if let Some(pos) = pos {
                                if start <= pos && pos <= end {
                                    let prefix = &input[start..pos];
                                    suggestions = Some(CommandSuggestions(
                                            self.$parser_field.suggestion(
                                                $( &$prev_parser_res, )* prefix
                                            )
                                    ));
                                }
                            }

                            let parse = self.$parser_field.parse(
                                $( &$prev_parser_res, )* arg);
                            let res = match parse {
                                ArgParseRes::Parsed(res) => res,
                                ArgParseRes::Failed { parsed_up_to, reason }
                                    => return (
                                        CommandParseRes::Failed {
                                            parsed_up_to: if parsed_up_to > 0 {
                                                start + parsed_up_to
                                            } else {
                                                prev_arg_end
                                            },
                                            reason: ArgumentParseFailed {
                                                from: start,
                                                to: end,
                                                reason,
                                            },
                                        },
                                        suggestions,
                                    ),
                            };

                            prev_arg_end = end;

                            res
                        }
                        None => {
                            // When `prev_arg_end` is 0 it means we are parsing
                            // the very first argument and we should provide
                            // suggestions for it.  Otherwise we need at least
                            // one extra character after the previous argument
                            // end.
                            if let Some(pos) = pos {
                                if prev_arg_end == 0 || pos > prev_arg_end {
                                    suggestions = Some(CommandSuggestions(
                                            self.$parser_field.suggestion(
                                                $( &$prev_parser_res, )* ""
                                            )
                                    ));
                                }
                            }

                            let hint = self.$parser_field.hint(
                                $( &$prev_parser_res, )*);
                            return (
                                CommandParseRes::Failed {
                                    parsed_up_to: prev_arg_end,
                                    reason: ExpectedArg {
                                        index: $arg_index,
                                        hint,
                                    },
                                },
                                suggestions,
                            );
                        }
                    };
                )*

                // We have used all the argument parsers we had.  But we still
                // have additional text to parse.

                let res = match args_iter.next() {
                    Some(m) => CommandParseRes::Failed {
                        parsed_up_to: prev_arg_end,
                        reason: UnexpectedArgument { from: m.start() },
                    },
                    None => {
                        let combined = (self.combine)($( $parser_res_var, )*);
                        CommandParseRes::Parsed(combined)
                    }
                };

                (res, suggestions)
            }
        }
    };
}

define_command_parser!(
    Command1ArgParser, Res,
    command_1arg,
    arg1_parser: <Parser1: ContextFreeArgParser> => res1: Res1 (_res1),
);
define_command_parser!(
    Command2ArgsParser, Res,
    command_2args,
    arg1_parser: <Parser1: ContextFreeArgParser> => res1: Res1 (_res1),
    arg2_parser: <Parser2: Arg2Parser> => res2: Res2 (_res2),
);
// define_command_parser!(Command3ArgsParser, Res,
//     arg1_parser: <Parser1: ContextFreeArgParser> => res1: Res1 (_res1),
//     arg2_parser: <Parser2: Arg2Parser> => res2: Res2 (_res2),
//     arg3_parser: <Parser3: Arg3Parser> => res3: Res3 (_res3),
// );

#[cfg(test)]
mod tests {
    use super::{
        command_1arg, command_2args, command_no_args, ArgParseRes,
        CommandParseFailure, CommandSuggestions,
    };

    use crate::input::arg_parser::keyword_set_with_hint;
    use crate::input::command_parser::test_utils::check_parse_and_failure_generator;

    use mocks::MockArg2Parser;

    macro_rules! vec_str {
        ($( $ex:expr ),* $(,)*) => {
            vec![ $( $ex.to_string() ),* ]
        };
    }

    #[test]
    fn no_arg_command() {
        let parser = command_no_args(|| true);

        let (check_parse, check_failure) =
            check_parse_and_failure_generator(parser);

        use CommandParseFailure::UnexpectedArgument;

        // == Parsed ==

        check_parse("", Some(0), true, None);
        for cur in 0..3 {
            check_parse("    ", Some(cur), true, None);
        }

        for cur in 0..3 {
            check_failure(
                "one",
                Some(cur),
                0,
                UnexpectedArgument { from: 0 },
                None,
            );
        }
        for cur in 0..6 {
            check_failure(
                "one two",
                Some(cur),
                0,
                UnexpectedArgument { from: 0 },
                None,
            );
        }
    }

    #[test]
    fn context_sensitive_arg1() {
        let arg1 = keyword_set_with_hint(
            vec!["simple", "one"].into_iter(),
            vec!["<keyword>"].into_iter(),
        );
        let parser = command_1arg(arg1, |keyword| keyword);

        let (check_parse, check_failure) =
            check_parse_and_failure_generator(parser);

        use CommandParseFailure::{
            ArgumentParseFailed, ExpectedArg, UnexpectedArgument,
        };

        // == ExpectedArg ==

        check_failure(
            "",
            Some(0),
            0,
            ExpectedArg {
                index: 0,
                hint: vec_str!["<keyword>"],
            },
            Some(CommandSuggestions(vec_str!["simple", "one"])),
        );

        // == Parsed ==

        for cur in 1..6 {
            check_parse(
                "simple",
                Some(cur),
                "simple".to_string(),
                Some(CommandSuggestions(vec_str!["simple"])),
            );
        }
        check_parse("simple", Some(7), "simple".to_string(), None);

        // == ArgumentParseFailed ==

        let input = "invalid one";
        //           0         1
        //           012345678901

        check_failure(
            input,
            Some(0),
            0,
            ArgumentParseFailed {
                from: 0,
                to: 7,
                reason: vec_str!["<keyword>"],
            },
            Some(CommandSuggestions(vec_str!["simple", "one"])),
        );
        for cur in 1..7 {
            check_failure(
                input,
                Some(cur),
                0,
                ArgumentParseFailed {
                    from: 0,
                    to: 7,
                    reason: vec_str!["<keyword>"],
                },
                Some(CommandSuggestions(vec_str![])),
            );
        }
        for cur in 8..11 {
            check_failure(
                input,
                Some(cur),
                0,
                ArgumentParseFailed {
                    from: 0,
                    to: 7,
                    reason: vec_str!["<keyword>"],
                },
                None,
            );
        }

        // == UnexpectedArgument ==

        check_failure(
            "simple one",
            Some(0),
            6,
            UnexpectedArgument { from: 7 },
            Some(CommandSuggestions(vec_str!["simple", "one"])),
        );
        for cur in 1..6 {
            check_failure(
                "simple one",
                Some(cur),
                6,
                UnexpectedArgument { from: 7 },
                Some(CommandSuggestions(vec_str!["simple"])),
            );
        }
        for cur in 7..10 {
            check_failure(
                "simple one",
                Some(cur),
                6,
                UnexpectedArgument { from: 7 },
                None,
            );
        }
    }

    #[test]
    fn context_sensitive_arg2() {
        let arg1 = keyword_set_with_hint(
            vec!["half", "halt", "hallo"].into_iter(),
            vec!["<keyword>"].into_iter(),
        );
        let arg2 = MockArg2Parser::new(
            "half".to_string(),
            "7",
            ArgParseRes::Parsed(1usize),
            "",
            vec_str!["1", "2", "7"],
            vec_str!["<some numbers>"],
        );
        let parser =
            command_2args(arg1, arg2.clone(), |keyword, x| (keyword, x));

        let (check_parse, check_failure) =
            check_parse_and_failure_generator(parser);

        use CommandParseFailure::{
            ArgumentParseFailed, ExpectedArg, UnexpectedArgument,
        };

        // == ExpectedArg ==

        check_failure(
            "",
            Some(0),
            0,
            ExpectedArg {
                index: 0,
                hint: vec_str!["<keyword>"],
            },
            Some(CommandSuggestions(vec_str!["half", "halt", "hallo"])),
        );

        // == Parsed ==

        for cur in 0..3 {
            check_parse(
                "half 7",
                Some(cur),
                ("half".to_string(), 1),
                Some(CommandSuggestions(vec_str!["half", "halt", "hallo"])),
            );
        }

        check_parse(
            "half 7",
            Some(4),
            ("half".to_string(), 1),
            Some(CommandSuggestions(vec![])),
        );
        check_parse(
            "half 7",
            Some(5),
            ("half".to_string(), 1),
            Some(CommandSuggestions(vec_str!["1", "2", "7"])),
        );

        {
            let mut arg2 = arg2.borrow_mut();
            arg2.suggestion_expected_prefix = "7";
        }
        // When the cursor is at the end of an argument we need to make sure we
        // still show suggestions for this argument.
        check_parse(
            "half 7",
            Some(6),
            ("half".to_string(), 1),
            Some(CommandSuggestions(vec_str!["1", "2", "7"])),
        );

        {
            let mut arg2 = arg2.borrow_mut();
            arg2.parse_expected_input = "77";
            arg2.suggestion_expected_prefix = "";
        }
        check_parse(
            "half 77",
            Some(4),
            ("half".to_string(), 1),
            Some(CommandSuggestions(vec![])),
        );
        check_parse(
            "half 77",
            Some(5),
            ("half".to_string(), 1),
            Some(CommandSuggestions(vec_str!["1", "2", "7"])),
        );
        {
            let mut arg2 = arg2.borrow_mut();
            arg2.suggestion_expected_prefix = "7";
            arg2.suggestion_res = vec_str!["77"];
        }
        check_parse(
            "half 77",
            Some(6),
            ("half".to_string(), 1),
            Some(CommandSuggestions(vec_str!["77"])),
        );

        // == ArgumentParseFailed ==

        {
            let mut arg2 = arg2.borrow_mut();
            arg2.parse_expected_input = "7";
            arg2.suggestion_expected_prefix = "";
            arg2.suggestion_res = vec_str!["1", "7"];
        }

        check_failure(
            "abc 7",
            Some(0),
            0,
            ArgumentParseFailed {
                from: 0,
                to: 3,
                reason: vec_str!["<keyword>"],
            },
            Some(CommandSuggestions(vec_str!["half", "halt", "hallo"])),
        );
        for cur in 1..3 {
            check_failure(
                "abc 7",
                Some(cur),
                0,
                ArgumentParseFailed {
                    from: 0,
                    to: 3,
                    reason: vec_str!["<keyword>"],
                },
                Some(CommandSuggestions(vec_str![])),
            );
        }
        for cur in 4..6 {
            check_failure(
                "abc 7",
                Some(cur),
                0,
                ArgumentParseFailed {
                    from: 0,
                    to: 3,
                    reason: vec_str!["<keyword>"],
                },
                None,
            );
        }

        // == UnexpectedArgument ==
        for cur in 0..3 {
            check_failure(
                "half 7 def",
                Some(cur),
                6,
                UnexpectedArgument { from: 7 },
                Some(CommandSuggestions(vec_str!["half", "halt", "hallo"])),
            );
        }
        check_failure(
            "half 7 def",
            Some(4),
            6,
            UnexpectedArgument { from: 7 },
            Some(CommandSuggestions(vec_str![])),
        );
        check_failure(
            "half 7 def",
            Some(5),
            6,
            UnexpectedArgument { from: 7 },
            Some(CommandSuggestions(vec_str!["1", "7"])),
        );

        {
            let mut arg2 = arg2.borrow_mut();
            arg2.suggestion_expected_prefix = "7";
        }
        check_failure(
            "half 7 def",
            Some(6),
            6,
            UnexpectedArgument { from: 7 },
            Some(CommandSuggestions(vec_str!["1", "7"])),
        );
        for cur in 7..10 {
            check_failure(
                "half 7 def",
                Some(cur),
                6,
                UnexpectedArgument { from: 7 },
                None,
            );
        }
    }

    mod mocks {
        use std::cell::RefCell;
        use std::fmt::Debug;
        use std::rc::Rc;

        use super::ArgParseRes;

        use crate::input::arg_parser::Arg2Parser;

        #[derive(PartialEq, Clone, Debug)]
        pub(super) struct MockArg2Parser<Res1, Res2>
        where
            Res1: Eq + Debug,
            Res2: Eq + Debug + Clone,
        {
            pub(super) expected_res1: Res1,
            pub(super) parse_expected_input: &'static str,
            pub(super) parse_res2: ArgParseRes<Res2>,
            pub(super) suggestion_expected_prefix: &'static str,
            pub(super) suggestion_res: Vec<String>,
            pub(super) hint_res: Vec<String>,
        }

        impl<Res1, Res2> MockArg2Parser<Res1, Res2>
        where
            Res1: Eq + Debug,
            Res2: Eq + Debug + Clone,
        {
            pub(super) fn new(
                expected_res1: Res1,
                parse_expected_input: &'static str,
                parse_res2: ArgParseRes<Res2>,
                suggestion_expected_prefix: &'static str,
                suggestion_res: Vec<String>,
                hint_res: Vec<String>,
            ) -> Rc<RefCell<Self>> {
                Rc::new(RefCell::new(MockArg2Parser {
                    expected_res1,
                    parse_expected_input,
                    parse_res2,
                    suggestion_expected_prefix,
                    suggestion_res,
                    hint_res,
                }))
            }
        }

        impl<Res1, Res2> Arg2Parser<Res1, Res2> for MockArg2Parser<Res1, Res2>
        where
            Res1: Eq + Debug,
            Res2: Eq + Debug + Clone,
        {
            fn parse(&self, res1: &Res1, input: &str) -> ArgParseRes<Res2> {
                assert_eq!(
                    &self.expected_res1, res1,
                    "MockArg2Parser::parse\n\
                     Expected res1: {:?}\n\
                     Actual res1:   {:?}",
                    &self.expected_res1, res1
                );
                assert_eq!(
                    self.parse_expected_input, input,
                    "MockArg2Parser::parse\n\
                     Expected input: \"{}\"\n\
                     Actual input:   \"{}\"",
                    self.parse_expected_input, input
                );
                self.parse_res2.clone()
            }

            fn suggestion(&self, res1: &Res1, prefix: &str) -> Vec<String> {
                assert_eq!(
                    &self.expected_res1, res1,
                    "MockArg2Parser::suggestion\n\
                     Expected res1: {:?}\n\
                     Actual res1:   {:?}",
                    &self.expected_res1, res1
                );
                assert_eq!(
                    self.suggestion_expected_prefix, prefix,
                    "MockArg2Parser::suggestion\n\
                     Expected prefix: \"{}\"\n\
                     Actual prefix:   \"{}\"",
                    self.suggestion_expected_prefix, prefix
                );
                self.suggestion_res.clone()
            }

            fn hint(&self, res1: &Res1) -> Vec<String> {
                assert_eq!(&self.expected_res1, res1);
                self.hint_res.clone()
            }
        }
    }
}
